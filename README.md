# uif
a toy UI framework

I have sort of a love/hate relationship with Angular, because it requires a lot of boilerplate.  But I like React even less, because it does the old AngularJS practice of every model used in a template must be prefaced with an object. (The name of the controller in AngularJS's case, "prop" or "state" in React's case.)  Most other frameworks I've seen, like Vue and Svelte, have the same issues.  

Semi-relatedly, I dislike the [flux](https://facebook.github.io/flux/docs/in-depth-overview.html#content) pattern that Redux et al uses also because of boilerplate. There's only 2½ languages that elegantly support function-invocation-is-a-hook-for-triggers, and that's Smalltalk, Objective-C, and AspectJ.  My employer used Flux in an Actionscript 3 (Flash) project.  Decoupling effects from events so that handlers don't need to know about each other sounds nice, but in practice they created race conditions affected by merely renaming a source file: the compiler hit the files in a different order, so the handlers ended up in a differnt order, and nothing is truly decoupled while it exists in the same app. Once the app gets big enough this source of bugs becomes a constant headache. Additionally, the IDE tooling couldn't follow the chain with "find all references" or similar. You had to do it manually everytime. The fact that Actionscript lacks generics like `Event<T>` means that by the time you found your way to the end of the chain, you'd have also forgotten what type the payload is.

This UI-framework chooses a convention-over-configuration approach with components / custom tags / custom elements:
* The HTML tag name is also the filename of the js, css, and html which implement it. All frameworks allow this through configuration, but here it's required.
* All 3 files are optional. They're requested anyway and any 404s are ignored because this toy doesn't operate with a manifest.
* The controller in the js file is the default export. You don't even need to name the class, just write `export default class {` and implement.
* (If you dislike default exports, then class name must match the tag name. Any hyphens or periods in the tagname are simply removed. I could add additional code to translate hyphenated tag names to TitleCase like Typescript prefers class names, but I've had bad experiences with AngularJS and its kebab-case vs camelCase distinctions. Hyphens aren't valid javascript identifiers so trying to name a class will stop the coder, though it may not be obvious that he merely needs to remove them. Hence, use default export.)
* You can put content between the opening and closing tags, to be inserted where `<innerHTML/>` appears in the enclosing component's template. TODO: that would probably make more sense as a controller property, like `{{innerHTML}}` or somesuch, rather than the special tag method that Angular uses.
* `<if>` and `<each>` (also called `for`) are their own elements instead of attribute-components. I find this cleaner and easier to learn, if a bit inconvenient at times. 
* The toy operates naïvely: instead of loading the app, it only loads components as it hits them in the HTML. Preloading [at least some of] them via a manifest listing the files would be more performant.
